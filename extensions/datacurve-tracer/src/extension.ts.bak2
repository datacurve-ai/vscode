import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { FileExplorer } from './fileExplorer';

export function activate(context: vscode.ExtensionContext) {
  const rootPath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
  
  if (rootPath) {
    // Create the file explorer
    const fileExplorer = new FileExplorer(rootPath);
    
    // Register the TreeDataProvider
    vscode.window.registerTreeDataProvider('customExplorer', fileExplorer);
    
    // Register commands
    const refreshCmd = vscode.commands.registerCommand('customExplorer.refresh', () => {
      fileExplorer.refresh();
    });
    
    const openFileCmd = vscode.commands.registerCommand('customExplorer.openFile', (resource: vscode.Uri) => {
      vscode.commands.executeCommand('vscode.open', resource);
    });
    
    const createFileCmd = vscode.commands.registerCommand('customExplorer.createFile', async (context) => {
      let targetUri: vscode.Uri;
      
      if (context) {
        targetUri = context.resourceUri;
      } else {
        if (!rootPath) { return; }
        targetUri = vscode.Uri.file(rootPath);
      }
      
      const stats = await vscode.workspace.fs.stat(targetUri);
      let parentUri: vscode.Uri;
      
      if (stats.type === vscode.FileType.Directory) {
        parentUri = targetUri;
      } else {
        parentUri = vscode.Uri.file(path.dirname(targetUri.fsPath));
      }
      
      const fileName = await vscode.window.showInputBox({
        prompt: 'Enter file name',
        validateInput: (value) => {
          if (value.length === 0) {
            return 'File name cannot be empty';
          }
          if (fs.existsSync(path.join(parentUri.fsPath, value))) {
            return 'File already exists';
          }
          return null;
        }
      });
      
      if (fileName) {
        const newFileUri = vscode.Uri.file(path.join(parentUri.fsPath, fileName));
        vscode.workspace.fs.writeFile(newFileUri, new Uint8Array([])).then(() => {
          fileExplorer.refresh();
          vscode.commands.executeCommand('vscode.open', newFileUri);
        });
      }
    });
    
    const createFolderCmd = vscode.commands.registerCommand('customExplorer.createFolder', async (context) => {
      let targetUri: vscode.Uri;
      
      if (context) {
        targetUri = context.resourceUri;
      } else {
        if (!rootPath) { return; }
        targetUri = vscode.Uri.file(rootPath);
      }
      
      const stats = await vscode.workspace.fs.stat(targetUri);
      let parentUri: vscode.Uri;
      
      if (stats.type === vscode.FileType.Directory) {
        parentUri = targetUri;
      } else {
        parentUri = vscode.Uri.file(path.dirname(targetUri.fsPath));
      }
      
      const folderName = await vscode.window.showInputBox({
        prompt: 'Enter folder name',
        validateInput: (value) => {
          if (value.length === 0) {
            return 'Folder name cannot be empty';
          }
          if (fs.existsSync(path.join(parentUri.fsPath, value))) {
            return 'Folder already exists';
          }
          return null;
        }
      });
      
      if (folderName) {
        const newFolderUri = vscode.Uri.file(path.join(parentUri.fsPath, folderName));
        vscode.workspace.fs.createDirectory(newFolderUri).then(() => {
          fileExplorer.refresh();
        });
      }
    });
    
    const deleteFileCmd = vscode.commands.registerCommand('customExplorer.deleteFile', async (context) => {
      const targetUri = context.resourceUri;
      const stats = await vscode.workspace.fs.stat(targetUri);
      
      let deleteMsg = 'Are you sure you want to delete this file?';
      let deleteOpts: vscode.MessageOptions = { modal: true };
      
      if (stats.type === vscode.FileType.Directory) {
        deleteMsg = 'Are you sure you want to delete this folder and all its contents?';
        deleteOpts = { modal: true };
      }
      
      const result = await vscode.window.showWarningMessage(deleteMsg, deleteOpts, 'Delete', 'Cancel');
      
      if (result === 'Delete') {
        try {
          if (stats.type === vscode.FileType.Directory) {
            await vscode.workspace.fs.delete(targetUri, { recursive: true });
          } else {
            await vscode.workspace.fs.delete(targetUri);
          }
          fileExplorer.refresh();
        } catch (err) {
          vscode.window.showErrorMessage(`Failed to delete: ${err}`);
        }
      }
    });
    
    const renameFileCmd = vscode.commands.registerCommand('customExplorer.renameFile', async (context) => {
      const targetUri = context.resourceUri;
      const oldName = path.basename(targetUri.fsPath);
      
      const newName = await vscode.window.showInputBox({
        prompt: 'Enter new name',
        value: oldName,
        validateInput: (value) => {
          if (value.length === 0) {
            return 'Name cannot be empty';
          }
          
          const parentFolder = path.dirname(targetUri.fsPath);
          const newPath = path.join(parentFolder, value);
          
          if (fs.existsSync(newPath) && newPath !== targetUri.fsPath) {
            return 'File or folder with this name already exists';
          }
          
          return null;
        }
      });
      
      if (newName && newName !== oldName) {
        const newUri = vscode.Uri.file(path.join(path.dirname(targetUri.fsPath), newName));
        
        try {
          await vscode.workspace.fs.rename(targetUri, newUri);
          fileExplorer.refresh();
        } catch (err) {
          vscode.window.showErrorMessage(`Failed to rename: ${err}`);
        }
      }
    });
    
    // Push all commands to subscriptions
    context.subscriptions.push(
      refreshCmd,
      openFileCmd,
      createFileCmd,
      createFolderCmd,
      deleteFileCmd,
      renameFileCmd
    );
  }
}
